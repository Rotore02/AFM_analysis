window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "afm_analysis", "modulename": "afm_analysis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "afm_analysis.data_analysis", "modulename": "afm_analysis.data_analysis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "afm_analysis.data_analysis.data_analysis_functions", "modulename": "afm_analysis.data_analysis.data_analysis_functions", "kind": "module", "doc": "<h1 id=\"data_analysis_functions-module\">data_analysis_functions module</h1>\n\n<p>This module contains the functions that perform data analysis \noperations.</p>\n\n<p>This module provides a set of functions that perform some\nmathematical or statistical operations on the already corrected \nheight values obtained from an AFM experiment. Each function performs \na single operation and provides data with a specific meaning.</p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.data_analysis.data_analysis_functions.height_distribution", "modulename": "afm_analysis.data_analysis.data_analysis_functions", "qualname": "height_distribution", "kind": "function", "doc": "<p>Generates the x and y axis of the plot that represents the \nheight distribution of the AFM image.</p>\n\n<p>This function returns the x and y axis of the plot that \nrepresents the distribution of the heights inside the \n<code>height_values</code> array. The height values are subdivided into \n100 bins ranging from <code>height_values.min()</code> to \n<code>height_values.max()</code> and the generated x axis of the \ndistribution plot is an array containing the bin centers.\nThe function <code>np.histogram</code> is used to generate the y axis, \ncounting the amount of height values <code>z</code> falling in each bin. \nThe bins are defined as the intervals \n[n\u22c5bin_width, (n+1)\u22c5bin_width), (including the left edge and \nexcluding the right edge) if n\u22c5bin_width &lt;= <code>z</code> &lt; (n+1)\u22c5bin_width, \nwith n integer that goes from 0 to 99.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of two ndarray\n    x and y axis of height distribution plot.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.histogram : function that computes the histogram of a dataset.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.data_analysis.data_analysis_functions.roughness_1d", "modulename": "afm_analysis.data_analysis.data_analysis_functions", "qualname": "roughness_1d", "kind": "function", "doc": "<p>Computes the 1-d roughness of the image and its standard deviation.</p>\n\n<p>This function computes the 1-d roughness along each fast scan \ndirection of the image (x axis) and thenit returns the mean of \nall these roughness values. This way of computing the roughness \nallows to return also the standard deviation, which is often \ntaken as the uncertainty associated to the mean roughness value.\nFinally, the mean of each 1-d roughness values and its standard \ndeviation are written in <code>results_file</code> if its internal state \n<code>enabled</code> is set to True.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.\nresults_file: SmartFile\n    File-like object that records results if its internal <code>enabled</code>\n    flag is True.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.std: function that computes the standard deviation along a \ncertain axis.\nnp.mean: function that computes the arithmetic mean along a \ncertain axis.\nsm.SmartFile: class to create files on which it is possible to \nwrite if their internal state <code>enabled</code> is set to True.\nroughness_2d: computes the roughness by exploiting the standard \ndeviation of all the image data.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The 1-d roughness expression for one fast scan direction is equal \nto the standard deviation computed for the data in that line, \nthis is the reason for which the numpy standard deviation function\nis used to return the roughness in that direction.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"n\">afm_analysis</span><span class=\"o\">.</span><span class=\"n\">smart_file</span><span class=\"o\">.</span><span class=\"n\">SmartFile</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.data_analysis.data_analysis_functions.roughness_2d", "modulename": "afm_analysis.data_analysis.data_analysis_functions", "qualname": "roughness_2d", "kind": "function", "doc": "<p>Computes the 2-d roughness of the image.</p>\n\n<p>This function computes the 2-d roughness of the image by \nexploiting the <code>np.std</code> function. The roughness value computed\nin this way is than written in <code>results_file</code> if its internal \nstate <code>enabled</code> is set to True.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.\nresults_file: SmartFile\n    File-like object that records results if its internal \n    <code>enabled</code> flag is True.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.std: function that computes the standard deviation along a \ncertain axis.\nsm.SmartFile: class to create files on which it is possible to \nwrite if their internal state <code>enabled</code> is set to True.\nroughness_1d: computes the roughness by mediating the 1-d \nroughness values of each fast scan line.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The 2-d roughness expression is equal to the standard deviation \ncomputed for all the data stored in the image, this is the reason \nfor which the numpy standard deviation function is used to return \nthe roughness in that direction.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"n\">afm_analysis</span><span class=\"o\">.</span><span class=\"n\">smart_file</span><span class=\"o\">.</span><span class=\"n\">SmartFile</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.data_analysis.data_analysis_pipeline", "modulename": "afm_analysis.data_analysis.data_analysis_pipeline", "kind": "module", "doc": "<h1 id=\"data_analysis_pipeline-module\">data_analysis_pipeline module</h1>\n\n<p>This module contains a single function that creates the pipeline \nof functions to perform data analysis.</p>\n\n<p>This module contains a function that, based on a settings \ndictionary, creates the pipeline of functions to perform the\ndata analysis of the AFM image data. The functions are taken \nfrom the 'data_analysis_functions' module.</p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.data_analysis.data_analysis_pipeline.build_data_analysis_pipeline", "modulename": "afm_analysis.data_analysis.data_analysis_pipeline", "qualname": "build_data_analysis_pipeline", "kind": "function", "doc": "<p>Builds the pipeline of execution of the data analysis functions.</p>\n\n<p>This functions defines a dictionary for each data analysis action. \nFor each action some keywords are defined and to each keyword is \nassociated a function (or a combination of them) inside the \n<code>data_analysis_functions</code> module. For each action, a function is \nadded to the execution pipeline based on the keywords parsed from \nthe <code>settings</code> dictionary. Some functions write their results in \n<code>results_file</code> (<code>sm.SmartFile</code> object), which internally can \nselect wether the writing is performed or not.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>settings: dict\n    File containing the keywords to choose the executed functions.\nresults_file: SmartFile\n    File-like object that records results if its internal <code>enabled</code> \n    flag is True.\nheight_values: ndarray\n    2-d grid containing the height values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list\n    list of the lambda functions to be executed based on the \n    <code>settings</code> file.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If the height distribution keyword in the <code>settings</code> file is \n    not valid.\nTypeError\n    If the roughness keyword in the <code>settings</code> file is not valid.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>data_analysis_functions: module with all the data analysis \nfunctions.\nsm.SmartFile: class to create files on which it is possible to \nwrite if their internal state <code>enabled</code> is set to True.\nfunctools.partial: class to create partial functions to fix some \narguments.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">settings</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.graphics", "modulename": "afm_analysis.graphics", "kind": "module", "doc": "<h1 id=\"graphics-module\">graphics module</h1>\n\n<p>This module contains the functions to perform graphical\noperations</p>\n\n<p>This module contains the functions to manage the .tiff file reading\nfrom the <em>input_files/</em> folder and the function to generate the \ncoordinate matrices on the x-y plane. It also has the functions that \ngenerate and save the output images and the plots inside the \n<em>output_files/</em> folder. </p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.graphics.read_tiff", "modulename": "afm_analysis.graphics", "qualname": "read_tiff", "kind": "function", "doc": "<p>Reads the tiff file.</p>\n\n<p>Reads an input tiff file and returns as output a 2-d array \nwhere each value is a corrisponding color in the tiff image.\nThe scaling factor can be selected, in order to represent the\nheights with their true physical values.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file_name: str\n    Name of the tiff file that needs to be read.\nscaling_factor: float\n    Factor that multiplies raw height values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    2-d grid containing numerical values representing each \n    pixel color.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If the file does is not a tiff file or does not have the\n    .tiff or .tif extensions (non case-sensitive).\nTypeError\n    If the height scaling factor is not a numerical value.\nFileNotFoundError\n    If the input file does not exist or is not in the \n    'input_files/' directory.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>tiff.TiffFile: class that reads the tiff file.\ntiff.TiffFile.asarray: method that converts the image \nin a numpy array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">height_scaling_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.graphics.create_coordinate_grid", "modulename": "afm_analysis.graphics", "qualname": "create_coordinate_grid", "kind": "function", "doc": "<p>Creates the coordinate grid in real space.</p>\n\n<p>Takes as inputs the scanning rate [m^(-1)] and the image width\n[m] and produces a couple of coordinate matrices of the image \nin real space. This is done to create a set of coordinates that\nrepresent the actual area scanned by the AFM, where to each \ncoordinate corresponds an height value.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>scanning_rate: float\n    Number of acquired points per unit length.\nimage_width: float\n    Edge length of the image.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of two ndarray\n    A couple of 2-d coordinate matrices with the dimensions of the \n    scanned area of the sample.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.meshgrid : Generates coordinate matrices from coordinate vectors.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scanning_rate</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">image_width</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.graphics.plot_2d_image", "modulename": "afm_analysis.graphics", "qualname": "plot_2d_image", "kind": "function", "doc": "<p>Plots AFM data as a 2D color map.</p>\n\n<p>Makes a 2-d plot of the height values stored in the 2-d grid \nlabeling the x and y axis of the plot with the coordinates \nstored in <code>coordinate_grid</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>output_file_name: str\n    Name of the output file that will be saved in the folder \n    'output_files/'.\nheight_values: ndarray\n    2-d grid with height values to be represented in the image.\ncoordinate_grid: tuple of two ndarray\n    Couple of 2-d arrays representing the x and y real space \n    coordinates for each image pixel.\ncolor_map: str\n    Set of colors to plot the image. Default is <code>Greys</code>.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If the inserted color map does not exist.\nValueError\n    If the scanning rate and the image length are not correct.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>plt.colormaps: register with a list of all colormaps aviable from \nmatplotlib.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_grid</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">color_map</span><span class=\"o\">=</span><span class=\"s1\">&#39;Greys&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.graphics.plot_3d_image", "modulename": "afm_analysis.graphics", "qualname": "plot_3d_image", "kind": "function", "doc": "<p>Plots AFM data as a 3D color map.</p>\n\n<p>Makes a 3-d plot of the height values stored in the 2-d grid \nlabeling the x and y axis of the plot with the coordinates \nstored in <code>coordinate_grid</code>.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>output_file_name: str\n    Name of the output file that will be saved in the folder \n    'output_files/'.\nheight_values: ndarray\n    2-d grid with height values to be represented in the image.\ncoordinate_grid: tuple of two ndarray\n    Couple of 2-d arrays representing the x and y real space \n    coordinates for each image pixel.\ncolor_map: str\n    Set of colors to plot the image. Default is <code>Greys</code>.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If the inserted color map does not exist.\nValueError\n    If the scanning rate and the image length are not correct.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>plt.colormaps: register with a list of all colormaps aviable \nfrom matplotlib.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_grid</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">color_map</span><span class=\"o\">=</span><span class=\"s1\">&#39;Greys&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.graphics.custom_plot", "modulename": "afm_analysis.graphics", "qualname": "custom_plot", "kind": "function", "doc": "<p>Plots the values stored in <code>data</code>.</p>\n\n<p>This function generates a plot of the data stored in <code>data</code>, \nwhere <code>data[0]</code> is the x axis and <code>data[1]</code> is the y axis.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data: tuple of two ndarray\n    Data of the x and y axis of the plot, respectively.\nax_labels: tuple of two strings\n    labels for the x and y axis, respectively. Default is \n    <code>(\"x\", \"y\")</code>.\ntitle: str\n    Title of the plot. Default is <code>\"Plot\"</code>.\ncolor: str\n    Color of the plotted data. Default is <code>\"black\"</code>.\nout_file_name: str\n    Name of the output plot file. Default is \n    <code>\"output_plot.pdf\"</code>.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>plt.plot: function used to plot the data.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">ax_labels</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;x&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;y&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;Plot&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">&#39;black&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">output_file_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;output_plot.pdf&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.image_correction", "modulename": "afm_analysis.image_correction", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "afm_analysis.image_correction.image_correction_functions", "modulename": "afm_analysis.image_correction.image_correction_functions", "kind": "module", "doc": "<h1 id=\"image_correction_functions-module\">image_correction_functions module</h1>\n\n<p>This module contains the functions that perform image\ncorrection operations.</p>\n\n<p>This module provides a set of functions that modify\nthe height values of the AFM raw image data. Each function\nmanages the correction of a certain kind of systematic\nerror that occours during an AFM experiment.</p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.image_correction.image_correction_functions.common_plane_subtraction", "modulename": "afm_analysis.image_correction.image_correction_functions", "qualname": "common_plane_subtraction", "kind": "function", "doc": "<p>Cancels out the planar slope of the image.</p>\n\n<p>Starting from the plane equation <code>z = a*x + b*y + c</code>, this \nfunction subtracts <code>A*x + B*y + C</code> to the height values \nof the AFM image, where the coefficients A and B are obtained \nby minimizing the square displacement between the plane and \nthe height values. This is done to eliminate any planar \ninclination due to sample positioning in the AFM microscope. \nThe plane parameters will be written in the results_file if \nits internal state <code>enabled</code> is set to True.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.\nresults_file: SmartFile\n    File-like object that records results if its internal \n    <code>enabled</code> flag is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    2-d grid with the height values subtracted by the common \n    plane.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.meshgrid : Generates coordinate matrices from coordinate \nvectors.\nnp.linalg.lstsq: function that returns the least-squares \nsolution to a linear matrix equation.\nsm.SmartFile: class to create files on which it is possible \nto write if their internal state <code>enabled</code> is set to True.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"n\">afm_analysis</span><span class=\"o\">.</span><span class=\"n\">smart_file</span><span class=\"o\">.</span><span class=\"n\">SmartFile</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.image_correction.image_correction_functions.mean_drift_subtraction", "modulename": "afm_analysis.image_correction.image_correction_functions", "qualname": "mean_drift_subtraction", "kind": "function", "doc": "<p>Cancels out the drift along the fast scan direction by mean \nsubtraction.</p>\n\n<p>This function computes the mean value of each line along \nthe fast scan direction (x axis) and subtracts this \nvalues to each height value in the line. This is done to \neliminate systematic drifts due to temperature variations \nor friction between the sample and the cantilever. The average \nmean value and its standard deviation are written in the \n<code>results_file</code> if its internal state <code>enabled</code> is set to True.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.\nresults_file: SmartFile\n    File-like object that records results if its internal \n    <code>enabled</code> flag is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    2-d grid with the height values corrected by mean \n    subtraction.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.mean: function that computes the arithmetic mean along a \ncertain axis.\nsm.SmartFile: class to create files on which it is possible \nto write if their internal state <code>enabled</code> is set to True.\nline_drift_subtraction: function that cancels out the drift \nalong the fast scan direction by line subtraction.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"n\">afm_analysis</span><span class=\"o\">.</span><span class=\"n\">smart_file</span><span class=\"o\">.</span><span class=\"n\">SmartFile</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.image_correction.image_correction_functions.linear_drift_subtraction", "modulename": "afm_analysis.image_correction.image_correction_functions", "qualname": "linear_drift_subtraction", "kind": "function", "doc": "<p>Cancels out the drift along the fast scan direction by line \nsubtraction.</p>\n\n<p>Starting from the line equation <code>z = m*x + q</code>, this function \nsubtracts <code>M*x + Q</code> to the height values of each fast scan \ndirection (x axis direction) of the AFM image, where the \ncoefficients M and Q are obtained by minimizing the square \ndisplacement between the line and the height values.\nThis is done to eliminate systematic drifts due to temperature \nvariations or friction between the sample and the cantilever. \nThe average values of M and Q and their standard deviation are \nwritten in the <code>results_file</code> if its internal state <code>enabled</code> \nis set to True.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.\nresults_file: SmartFile\n    File-like object that records results if its internal \n    <code>enabled</code> flag is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    2-d grid with the height values corrected by line \n    subtraction.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.linalg.lstsq: function that returns the least-squares \nsolution to a linear matrix equation.\nsm.SmartFile: class to create files on which it is possible \nto write if their internal state <code>enabled</code> is set to True.\nmean_drift_subtraction: function that cancels out the drift \nalong the fast scan direction by mean subtraction.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"n\">afm_analysis</span><span class=\"o\">.</span><span class=\"n\">smart_file</span><span class=\"o\">.</span><span class=\"n\">SmartFile</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.image_correction.image_correction_functions.shift_min", "modulename": "afm_analysis.image_correction.image_correction_functions", "qualname": "shift_min", "kind": "function", "doc": "<p>Sets the minimum height value to zero.</p>\n\n<p>Finds the minimum height inside the height_values array and \nsubtracts its value to each element of the array, thus shifting \nthe image such that the minimum height corresponds to zero.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    2-d grid with the height values subtracted by the minimum \n    height value.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>shift_mean: function that sets the mean height to zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.image_correction.image_correction_functions.shift_mean", "modulename": "afm_analysis.image_correction.image_correction_functions", "qualname": "shift_mean", "kind": "function", "doc": "<p>Sets the mean height value to zero.</p>\n\n<p>Computes the mean height inside the height_values array and \nsubtracts its value to each element of the array, thus shifting \nthe image such that the mean height corresponds to zero.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>height_values: ndarray\n    2-d grid containing the height values.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ndarray\n    2-d grid with the height values subtracted by the mean \n    height value.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>np.mean: function that computes the arithmetic mean along a \ncertain axis.\nshift_min: function that sets the minimum height value to zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">height_values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.image_correction.image_correction_pipeline", "modulename": "afm_analysis.image_correction.image_correction_pipeline", "kind": "module", "doc": "<h1 id=\"image_correction_pipeline-module\">image_correction_pipeline module</h1>\n\n<p>This module contains a single function that creates a pipeline \nof functions to perform image correction.</p>\n\n<p>This module contains a function that, based on a settings \ndictionary, creates the pipeline of functions to correct\nthe AFM image data. The functions are taken from the\n'image_correction_functions' module.</p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.image_correction.image_correction_pipeline.build_image_correction_pipeline", "modulename": "afm_analysis.image_correction.image_correction_pipeline", "qualname": "build_image_correction_pipeline", "kind": "function", "doc": "<p>Builds the pipeline of execution of the image correction \nfunctions.</p>\n\n<p>This functions defines a dictionary for each image correction \naction. For each action some keywords are defined and to each \nkeyword is associated a function (or a combination of them) inside\nthe <code>image_correction_functions</code> module. For each action, a \nfunction is added to the execution pipeline based on the keywords \nparsed from the <code>settings</code> dictionary. Some functions write their \nresults in <code>results_file</code> (<code>sm.SmartFile</code> object), which \ninternally can select wether the writing is performed or not.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>settings: dict\n    File containing the keywords to choose the executed functions\nresults_file: SmartFile\n    File-like object that records results if its internal \n    <code>enabled</code> flag is True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list\n    list of the functions to be executed based on the <code>settings</code> \n    file.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    If the plane subtraction keyword in the <code>settings</code> file is \n    not valid.\nTypeError\n    If the line subtraction keyword in the <code>settings</code> file is \n    not valid.\nTypeError\n    If the data shift keyword in the <code>settings</code> file is not \n    valid.\nUserWarning\n    If any kind of line drift correction is requested without \n    plane subtraction.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>image_correction_functions: module with all the image correcting \nfunctions.\nsm.SmartFile: class to create files on which it is possible to \nwrite if their internal state <code>enabled</code> is set to True.\nfunctools.partial: class to create partial functions to fix some \narguments.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">settings</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">results_file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.run_afm_analysis", "modulename": "afm_analysis.run_afm_analysis", "kind": "module", "doc": "<h1 id=\"run_afm_analysis-module\">run_afm_analysis module</h1>\n\n<p>This module is the main script of the project. It manages the\nexecution of the functions in the pipelines.</p>\n\n<p>This script reads the .tiff input file from the <em>input_files/</em> folder \nand enables the results file writing if specified by the \nexecution command (see step 3. of 'Running the Analysis' in the \n'Tutorial' section of the README.md). It executes the \nfunctions in the pipelines for both image correction and data \nanalysis. Finally it generates the output images inside the \n'output_files/' folder.</p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.run_afm_analysis.main", "modulename": "afm_analysis.run_afm_analysis", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.smart_file", "modulename": "afm_analysis.smart_file", "kind": "module", "doc": "<h1 id=\"smart_file-module\">smart_file module</h1>\n\n<p>This module defines the class SmartFile and its methods. </p>\n\n<p>Author: Alessandro Rotondi</p>\n"}, {"fullname": "afm_analysis.smart_file.SmartFile", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile", "kind": "class", "doc": "<p>Can be used to build a file-like object in which one can \ndynamically write.</p>\n\n<p>This class can be used to create a file-like object in which an \naction defined by its methods is performed only if its internal\nattribute <code>enabled</code> is set to <code>True</code>.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>enabled: bool\n    Checks wether the action is performed or not.\nfile: str\n    Name of the file to which the action is performed.</p>\n\n<h2 id=\"methods\">Methods</h2>\n\n<p>setup(file_name)\n    sets the <code>enabled</code> attribute to <code>True</code> and opens the file.\nwrite(message)\n    writes <code>message</code> to the file.\nclose()\n    closes the opened file.</p>\n"}, {"fullname": "afm_analysis.smart_file.SmartFile.__init__", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile.__init__", "kind": "function", "doc": "<p>Initializes the SmartFile object with <code>enabled = False</code> and \n<code>file = None</code> by default.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "afm_analysis.smart_file.SmartFile.enabled", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile.enabled", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "afm_analysis.smart_file.SmartFile.file", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile.file", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "afm_analysis.smart_file.SmartFile.setup", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile.setup", "kind": "function", "doc": "<p>Sets the <code>enabled</code> attribute to <code>True</code> and opens the file \nwith name <code>file_name</code>.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<p>file_name: str\n    Name or path of the file that is opened.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">file_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.smart_file.SmartFile.write", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile.write", "kind": "function", "doc": "<p>Writes the string <code>message</code> in the file only if <code>enabled</code> \nis set to <code>True</code> and <code>file</code> is not <code>None</code>.</p>\n\n<h2 id=\"args\">Args</h2>\n\n<p>message: str\n    string that is written on the file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">message</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "afm_analysis.smart_file.SmartFile.close", "modulename": "afm_analysis.smart_file", "qualname": "SmartFile.close", "kind": "function", "doc": "<p>Closes the file object if <code>enabled</code> is set to <code>True</code> and \n<code>file</code> is not <code>None</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();